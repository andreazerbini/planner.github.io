<!doctype html>
<html lang="it">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Kanban Covey – Tabs + Tabelle + Drive</title>
    <style>
      :root {
        --bg: #0b0f16;
        --panel: #121826;
        --muted: #9aa4b2;
        --text: #e6edf3;
        --accent: #5eead4;
        --card: #0f172a;
        --border: #263046;
        --warn: #f59e0b;
        --danger: #ef4444;
        --h-header: 56px;
        --h-tabs: 46px;
        --sticky-top: calc(var(--h-header) + var(--h-tabs));
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: Inter, system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
        color: var(--text);
        background: linear-gradient(120deg, #0b0f16, #0a1322 60%, #0b0f16);
      }

      header {
        position: sticky;
        top: 0;
        z-index: 20;
        display: flex;
        align-items: center;
        gap: 0.8rem;
        height: var(--h-header);
        padding: 1rem;
        border-bottom: 1px solid var(--border);
        background: rgba(11, 15, 22, 0.7);
        backdrop-filter: blur(8px);
      }

      h1 {
        margin: 0;
        font-size: 1.05rem;
        font-weight: 700;
        letter-spacing: 0.2px;
      }

      .tag {
        padding: 0.25rem 0.5rem;
        font-size: 0.75rem;
        color: var(--muted);
        border: 1px solid var(--border);
        border-radius: 999px;
      }

      .actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        margin-left: auto;
      }

      button,
      input,
      select,
      textarea {
        font: inherit;
      }

      button {
        padding: 0.55rem 0.75rem;
        color: var(--text);
        border: 1px solid var(--border);
        border-radius: 0.75rem;
        background: var(--panel);
        cursor: pointer;
      }

      button:hover {
        border-color: #33405e;
      }

      button.primary {
        color: #061317;
        border-color: transparent;
        background: linear-gradient(135deg, #12b3a6, #6ee7d2);
      }

      button.primary:hover {
        filter: brightness(1.02);
      }

      button.danger {
        color: #2b100f;
        border-color: transparent;
        background: linear-gradient(135deg, #ef4444, #f59e0b);
      }

      nav.tabs {
        position: sticky;
        top: var(--h-header);
        z-index: 15;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        height: var(--h-tabs);
        padding: 0.6rem 1rem;
        border-bottom: 1px solid var(--border);
        background: rgba(11, 15, 22, 0.7);
        backdrop-filter: blur(8px);
      }

      .tab {
        padding: 0.45rem 0.75rem;
        color: var(--muted);
        border: 1px solid var(--border);
        border-radius: 0.65rem;
        cursor: pointer;
        background: transparent;
      }

      .tab.active {
        color: #061317;
        border-color: transparent;
        background: linear-gradient(135deg, #12b3a6, #6ee7d2);
      }

      main {
        display: grid;
        gap: 1rem;
        padding: 1rem;
      }

      table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        background: rgba(18, 24, 38, 0.7);
        border: 1px solid var(--border);
        border-radius: 0.9rem;
        overflow: hidden;
      }

      thead th {
        /* position: sticky; */
        top: var(--sticky-top);
        z-index: 10;
        padding: 0.7rem 0.8rem;
        font-size: 0.85rem;
        text-align: left;
        white-space: nowrap;
        color: var(--muted);
        user-select: none;
        background: #121826;
        border-bottom: 1px solid var(--border);
      }

      th.sortable {
        cursor: pointer;
      }

      th.sortable::after {
        margin-left: 0.25rem;
        font-size: 0.7rem;
        opacity: 0.35;
        content: "▲▼";
      }

      th.sortable.asc::after {
        content: "▲";
        opacity: 0.85;
      }

      th.sortable.desc::after {
        content: "▼";
        opacity: 0.85;
      }

      tbody td {
        padding: 0.6rem 0.8rem;
        border-bottom: 1px solid #1b2436;
      }

      tbody tr:hover {
        background: #0f1628;
      }

      tbody tr:last-child td {
        border-bottom: none;
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
      }

      .controls.filters {
        align-items: flex-end;
        gap: 0.75rem;
      }

      .filter-field {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
        min-width: 140px;
        font-size: 0.75rem;
        color: var(--muted);
      }

      .filter-field.filter-tree {
        min-width: 260px;
        flex: 1 1 320px;
      }

      .filter-field.filter-tree .hierarchy-filter {
        width: 100%;
      }

      .filter-field input,
      .filter-field select {
        width: 100%;
      }

      .hierarchy-filter {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        max-height: 220px;
        padding: 0.35rem 0.45rem;
        border: 1px solid var(--border);
        border-radius: 0.5rem;
        background: #0b1324;
        overflow: auto;
      }

      .hierarchy-node {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }

      .hierarchy-row {
        display: flex;
        align-items: center;
        gap: 0.4rem;
        color: var(--text);
        font-size: 0.78rem;
      }

      .hierarchy-row.is-empty {
        color: var(--muted);
        font-style: italic;
      }

      .hierarchy-row span {
        flex: 1;
      }

      .hierarchy-children {
        display: flex;
        flex-direction: column;
        gap: 0.3rem;
        margin-left: 1.5rem;
      }

      .hierarchy-children .hierarchy-children {
        margin-left: 1.25rem;
      }

      input[type="text"],
      input[type="number"],
      input[type="date"],
      select,
      textarea {
        width: 100%;
        padding: 0.45rem 0.5rem;
        color: var(--text);
        border: 1px solid var(--border);
        border-radius: 0.5rem;
        background: #0b1324;
      }

      textarea {
        min-height: 54px;
        resize: vertical;
      }

      .kanban {
        display: grid;
        grid-auto-flow: column;
        grid-auto-columns: minmax(260px, 1fr);
        gap: 1rem;
        overflow-x: auto;
        padding-bottom: 0.5rem;
      }

      .kanban-column {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        min-height: 200px;
        padding: 0.9rem;
        border: 1px solid var(--border);
        border-radius: 0.9rem;
        background: rgba(18, 24, 38, 0.7);
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
      }

      .kanban-column.dragover {
        border-color: var(--accent);
        box-shadow: 0 0 0 1px var(--accent);
      }

      .kanban-column-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
        font-weight: 600;
      }

      .kanban-column-count {
        font-size: 0.8rem;
        color: var(--muted);
      }

      .kanban-column-body {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        min-height: 48px;
      }

      .kanban-column-placeholder {
        margin: 0;
        padding: 1rem;
        font-size: 0.85rem;
        color: var(--muted);
        text-align: center;
        border: 1px dashed var(--border);
        border-radius: 0.8rem;
      }

      .kanban-card {
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
        padding: 0.8rem;
        border: 1px solid var(--border);
        border-radius: 0.85rem;
        background: var(--card);
        transition: transform 0.15s ease, box-shadow 0.15s ease;
        cursor: grab;
      }

      .kanban-card.dragging {
        opacity: 0.6;
      }

      .kanban-card:active {
        cursor: grabbing;
      }

      .kanban-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.35);
      }

      .kanban-card-hierarchy {
        font-size: 0.75rem;
        color: var(--muted);
      }

      .kanban-card-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 0.35rem;
      }

      .kanban-card .description {
        font-size: 0.85rem;
        color: var(--muted);
      }

      .badge {
        display: inline-block;
        padding: 0.1rem 0.45rem;
        font-size: 0.7rem;
        color: var(--muted);
        border: 1px solid var(--border);
        border-radius: 0.5rem;
      }

      .title {
        font-weight: 700;
      }

      .task-state-select {
        --state-color: var(--border);
        border: 2px solid var(--state-color);
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
      }

      .task-state-select:focus {
        box-shadow: 0 0 0 2px rgba(94, 234, 212, 0.35);
      }

      .footer {
        padding: 1rem;
        font-size: 0.85rem;
        color: var(--muted);
        border-top: 1px solid var(--border);
      }

      @media (max-width: 700px) {
        header {
          align-items: flex-start;
        }

        .kanban {
          grid-auto-columns: minmax(220px, 1fr);
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Kanban Covey</h1>
      <span class="tag">Ruoli → LT → BT → Attività</span>
      <div class="actions">
        <button id="export">Esporta JSON</button>
        <button id="importBtn">Importa JSON</button>
        <button id="saveFile">Salva su file</button>
        <button id="openFile">Apri file</button>
        <button id="gSignIn">Connetti Google</button>
        <button id="driveOpen" disabled>Apri da Drive</button>
        <button id="driveSave" disabled>Salva su Drive</button>
        <span id="driveStatus" class="tag" title="Stato Google Drive">Drive: offline</span>
        <button class="danger" id="clear">Azzera</button>
      </div>
    </header>

    <nav id="tabs" class="tabs"></nav>
    <main id="view"></main>

    <footer class="footer">
      <strong>Salvataggio locale:</strong> automatico in <code>localStorage</code>.
      Puoi anche <em>Esportare/Importare</em> JSON.
      Su browser Chromium/Edge puoi usare "Salva su file" e "Apri file" (File System Access API).
      <br />
      Opzionale: connessione a <strong>Google Drive</strong> (inserisci <em>Client ID</em> e <em>API Key</em>) per aprire/salvare il JSON.
    </footer>

    <input id="filePicker" type="file" accept="application/json" hidden />
    <input
      id="taskCsvPicker"
      type="file"
      accept="text/csv,.csv"
      hidden
    />

    <script>
      (() => {
        "use strict";

        // =============================================================
        // Costanti e configurazione di base
        // =============================================================
        const STORAGE_KEYS = Object.freeze({
          STATE: "covey_v2_domain_model",
          GD_CLIENT_ID: "covey_gd_client_id",
          GD_API_KEY: "covey_gd_api_key",
        });

        const DEFAULT_FILE_NAME = "kanban-covey.json";
        const GOOGLE_DISCOVERY_DOCS = [
          "https://www.googleapis.com/discovery/v1/apis/drive/v3/rest",
        ];
        const GOOGLE_SCOPE = "https://www.googleapis.com/auth/drive.file";

        const TASK_STATE_IDS = Object.freeze({
          TO_REFINE: "to_refine",
          TO_DO: "to_do",
          IN_PROGRESS: "in_progress",
          PAUSED: "paused",
          DONE: "done",
          REJECTED: "rejected",
        });

        const TASK_STATES = [
          {
            id: TASK_STATE_IDS.TO_REFINE,
            label: "Da pensare meglio",
            color: "#9ca3af",
          },
          {
            id: TASK_STATE_IDS.TO_DO,
            label: "Da fare",
            color: "#38bdf8",
          },
          {
            id: TASK_STATE_IDS.IN_PROGRESS,
            label: "In evoluzione",
            color: "#facc15",
          },
          {
            id: TASK_STATE_IDS.PAUSED,
            label: "Paused",
            color: "#f97316",
          },
          {
            id: TASK_STATE_IDS.DONE,
            label: "Fatto",
            color: "#22c55e",
          },
          {
            id: TASK_STATE_IDS.REJECTED,
            label: "Rejected",
            color: "#ef4444",
          },
        ];

        const DEFAULT_TASK_STATE = TASK_STATE_IDS.TO_DO;
        const TASK_STATE_BY_ID = new Map(
          TASK_STATES.map((state) => [state.id, state])
        );

        const tabs = [
          { id: "roles", label: "Ruoli" },
          { id: "lt", label: "Obiettivi a lungo termine" },
          { id: "st", label: "Obiettivi a breve termine" },
          { id: "tasks", label: "Attività" },
          { id: "dash", label: "Dashboard" },
        ];

        // =============================================================
        // Stato applicativo e persistence layer
        // =============================================================
        const AppState = {
          data: loadState(),
          currentFileHandle: null,
          persist() {
            localStorage.setItem(
              STORAGE_KEYS.STATE,
              JSON.stringify(this.data)
            );
          },
          replace(nextState) {
            normalizeDomain(nextState);
            this.data = nextState;
            this.persist();
          },
          nextId() {
            return String(this.data.nextId++);
          },
        };

        function defaultState() {
          return { nextId: 1, roles: [] };
        }

        function loadState() {
          try {
            const raw = localStorage.getItem(STORAGE_KEYS.STATE);
            if (!raw) return seedState();
            const parsed = JSON.parse(raw);
            if (!validate(parsed)) return seedState();
            normalizeDomain(parsed);
            return parsed;
          } catch (err) {
            console.warn("Impossibile leggere lo stato salvato, uso seed.", err);
            return seedState();
          }
        }

        function seedState() {
          const seeded = defaultState();
          const today = () => new Date().toISOString().slice(0, 10);
          const datePlus = (days) => {
            const date = new Date();
            date.setDate(date.getDate() + days);
            return date.toISOString().slice(0, 10);
          };
          const nextId = () => String(seeded.nextId++);

          const role = {
            id: nextId(),
            title: "Team Leader",
            importance: 3,
            lt_goals: [],
          };
          const longTerm = {
            id: nextId(),
            title: "Introdurre ML nel prodotto",
            description: "Roadmap ML (RAG, valutazione, privacy)",
            importance: 5,
            due: datePlus(120),
            st_goals: [],
          };
          const shortTerm = {
            id: nextId(),
            title: "PoC RAG su documentale",
            description: "Pipeline base eval + feedback",
            importance: null,
            due: null,
            tasks: [],
          };
          const task = {
            id: nextId(),
            title: "Progettazione schema vector DB",
            description: "Definire spazio embedding e chunking",
            importance: 4,
            due: datePlus(30),
            state: TASK_STATE_IDS.TO_DO,
          };

          shortTerm.tasks.push(task);
          longTerm.st_goals.push(shortTerm);
          role.lt_goals.push(longTerm);
          seeded.roles.push(role);
          normalizeDomain(seeded);
          return seeded;
        }

        function validate(candidate) {
          return (
            candidate &&
            typeof candidate === "object" &&
            Array.isArray(candidate.roles) &&
            "nextId" in candidate
          );
        }

        function getTaskStateId(stateId) {
          return TASK_STATE_BY_ID.has(stateId) ? stateId : DEFAULT_TASK_STATE;
        }

        function getTaskStateConfig(stateId) {
          return TASK_STATE_BY_ID.get(getTaskStateId(stateId));
        }

        function normalizeTask(task) {
          if (!task || typeof task !== "object") return;
          task.state = getTaskStateId(task.state);
        }

        function normalizeDomain(root) {
          if (!root || typeof root !== "object") return;
          if (!Array.isArray(root.roles)) {
            root.roles = [];
          }
          root.roles.forEach((role) => {
            role.lt_goals = Array.isArray(role.lt_goals) ? role.lt_goals : [];
            role.lt_goals.forEach((lt) => {
              lt.st_goals = Array.isArray(lt.st_goals) ? lt.st_goals : [];
              lt.st_goals.forEach((st) => {
                st.tasks = Array.isArray(st.tasks) ? st.tasks : [];
                st.tasks.forEach(normalizeTask);
              });
            });
          });
        }

        function findTaskRef({ roleId, ltId, stId, taskId }) {
          const role = AppState.data.roles.find((candidate) => candidate.id === roleId);
          if (!role) return null;
          const lt = role.lt_goals.find((candidate) => candidate.id === ltId);
          if (!lt) return null;
          const st = lt.st_goals.find((candidate) => candidate.id === stId);
          if (!st) return null;
          const task = st.tasks.find((candidate) => candidate.id === taskId);
          if (!task) return null;
          return { role, lt, st, task };
        }

        // =============================================================
        // Utilità di formattazione e coercizione
        // =============================================================
        const DateUtils = {
          today: () => new Date().toISOString().slice(0, 10),
          addDays(days) {
            const date = new Date();
            date.setDate(date.getDate() + days);
            return date.toISOString().slice(0, 10);
          },
        };

          function toImportance(value, fallback = 1) {
              const parsed = parseInt(value, 10);
              if (Number.isNaN(parsed)) return fallback;
              return Math.max(1, parsed); // ← niente limite superiore
          }

        function toImportanceOrNull(value) {
          if (value == null || value === "") return null;
          return toImportance(value, 1);
        }

        // =============================================================
        // Ereditarietà di importanza/scadenza
        // =============================================================
        function effectiveImportance(node, parentImportance) {
          return node.importance != null
            ? toImportance(node.importance, 1)
            : parentImportance;
        }

        function effectiveDueDate(node, parentDueDate) {
          return node.due || parentDueDate || null;
        }

        function clampChildToParent(child, parent) {
          const parentImportance = effectiveImportance(parent, 9999999);
          const parentDue = parent.due || null;

          if (
            child.importance != null &&
            child.importance > parentImportance
          ) {
            child.importance = parentImportance;
          }

          if (parentDue && child.due && child.due > parentDue) {
            child.due = parentDue;
          }
        }

          function cascadeFromRole(role) {
              role.lt_goals.forEach((lt) => {
                  // LT non può superare il Ruolo
                  clampChildToParent(lt, role);

                  lt.st_goals.forEach((st) => {
                      clampChildToParent(st, lt);
                      st.tasks.forEach((task) =>
                          clampChildToParent(task, st.due ? st : lt)
                      );
                  });
              });
          }


        // =============================================================
        // UI references e gestione tab
        // =============================================================
        const dom = {
          tabs: document.getElementById("tabs"),
          view: document.getElementById("view"),
          filePicker: document.getElementById("filePicker"),
          taskCsvPicker: document.getElementById("taskCsvPicker"),
          exportBtn: document.getElementById("export"),
          importBtn: document.getElementById("importBtn"),
          saveFileBtn: document.getElementById("saveFile"),
          openFileBtn: document.getElementById("openFile"),
          clearBtn: document.getElementById("clear"),
          driveStatus: document.getElementById("driveStatus"),
          googleBtn: document.getElementById("gSignIn"),
          driveOpenBtn: document.getElementById("driveOpen"),
          driveSaveBtn: document.getElementById("driveSave"),
        };

        function requestTaskCsvImport() {
          if (!dom.taskCsvPicker) return;
          dom.taskCsvPicker.value = "";
          dom.taskCsvPicker.click();
        }

        dom.taskCsvPicker?.addEventListener("change", async (event) => {
          const file = event.target.files?.[0];
          if (!file) return;
          try {
            const text = await file.text();
            const imported = importTasksFromCsvContent(text);
            AppState.persist();
            render();
            alert(`Importate ${imported} attività da CSV ✅`);
          } catch (error) {
            alert(`Errore import CSV: ${error.message || error}`);
          } finally {
            dom.taskCsvPicker.value = "";
          }
        });

        let activeTab = "roles";

        function render() {
          renderTabs();
          const renderer = tabRenderers[activeTab];
          if (renderer) renderer();
        }

        function renderTabs() {
          dom.tabs.innerHTML = "";
          tabs.forEach((tab) => {
            const element = document.createElement("button");
            element.className = `tab${activeTab === tab.id ? " active" : ""}`;
            element.textContent = tab.label;
            element.addEventListener("click", () => {
              activeTab = tab.id;
              render();
            });
            dom.tabs.appendChild(element);
          });
        }

        const tabRenderers = {
          roles: renderRoles,
          lt: renderLongTermGoals,
          st: renderShortTermGoals,
          tasks: renderTasks,
          dash: renderDashboard,
        };

        // =============================================================
        // Helper UI element factories
        // =============================================================
        function inputText(value, placeholder, onInput) {
          const input = document.createElement("input");
          input.type = "text";
          input.value = value || "";
          if (placeholder) input.placeholder = placeholder;
          if (onInput) {
            input.addEventListener("input", () => onInput(input.value));
          }
          return input;
        }

        function inputInteger(value, onInput) {
          const input = document.createElement("input");
          input.type = "number";
          input.min = "1";
          // input.max = "99999";
          input.step = "1";
          input.value = value ?? "";
          input.addEventListener("input", () => {
            onInput(input.value === "" ? null : toImportance(input.value));
          });
          return input;
        }

          function inputDate(value, onInput, { readOnly = false } = {}) {
              const input = document.createElement("input");
              input.type = "date";
              input.value = value || "";

              // Solo se esplicitamente richiesto, blocca la digitazione
              if (readOnly) {
                  input.readOnly = true;
                  input.addEventListener("keydown", (e) => e.preventDefault());
              }

              // Apri il calendario automaticamente al focus
              input.addEventListener("focus", () => {
                  // Questo funziona sulla maggior parte dei browser moderni
                  try {
                      input.showPicker?.();
                  } catch (e) {
                      // Fallback silenzioso se non supportato
                  }
              });

              // Aggiorna lo stato quando cambia la data
              input.addEventListener("change", () => {
                  onInput(input.value || null);
              });

              // Anche su input per catturare la digitazione
              input.addEventListener("input", () => {
                  onInput(input.value || null);
              });

              return input;
          }

        function textArea(value, onInput) {
          const area = document.createElement("textarea");
          area.value = value || "";
          area.addEventListener("input", () => onInput(area.value));
          return area;
        }

        function button(label, className, onClick) {
          const btn = document.createElement("button");
          btn.textContent = label;
          if (className) btn.className = className;
          btn.addEventListener("click", onClick);
          return btn;
        }

        const TASK_CSV_FILE_NAME = "kanban-covey-tasks.csv";
        const TASK_CSV_HEADERS = Object.freeze([
          "Ruolo",
          "LT",
          "ST",
          "Titolo",
          "Descrizione",
          "Importanza",
          "Scadenza",
          "Stato",
        ]);

        const TASK_CSV_COLUMN_ALIASES = Object.freeze({
          role: ["ruolo", "role"],
          lt: ["lt", "obiettivo lt", "lungo termine", "long term", "long-term"],
          st: [
            "st",
            "bt",
            "obiettivo bt",
            "breve termine",
            "short term",
            "short-term",
          ],
          title: ["titolo", "title"],
          description: ["descrizione", "description"],
          importance: ["importanza", "importance"],
          due: ["scadenza", "due", "deadline", "data"],
          state: ["stato", "state"],
        });

        const TASK_CSV_COLUMN_LABELS = Object.freeze({
          role: "Ruolo",
          lt: "LT",
          st: "ST",
          title: "Titolo",
          description: "Descrizione",
          importance: "Importanza",
          due: "Scadenza",
          state: "Stato",
        });

        function createHierarchyState() {
          return Object.create(null);
        }

        function cloneHierarchyState(source) {
          const clone = Object.create(null);
          Object.entries(source || {}).forEach(([roleId, roleEntry]) => {
            const roleClone = {
              includeAll: Boolean(roleEntry.includeAll),
              lts: Object.create(null),
            };
            Object.entries(roleEntry.lts || {}).forEach(([ltId, ltEntry]) => {
              roleClone.lts[ltId] = {
                includeAll: Boolean(ltEntry.includeAll),
                sts: Object.assign(Object.create(null), ltEntry.sts || {}),
              };
            });
            clone[roleId] = roleClone;
          });
          return clone;
        }

        function normalizeHierarchyState(source) {
          const normalized = cloneHierarchyState(source);
          Object.entries(normalized).forEach(([roleId, roleEntry]) => {
            if (roleEntry.includeAll) {
              roleEntry.lts = Object.create(null);
              return;
            }
            Object.entries(roleEntry.lts).forEach(([ltId, ltEntry]) => {
              if (ltEntry.includeAll) {
                ltEntry.sts = Object.create(null);
                return;
              }
              Object.keys(ltEntry.sts).forEach((stId) => {
                if (!ltEntry.sts[stId]) {
                  delete ltEntry.sts[stId];
                }
              });
              if (Object.keys(ltEntry.sts).length === 0) {
                delete roleEntry.lts[ltId];
              }
            });
            if (Object.keys(roleEntry.lts).length === 0) {
              delete normalized[roleId];
            }
          });
          return normalized;
        }

        function hierarchyFilterIsEmpty(hierarchy) {
          return !hierarchy || Object.keys(hierarchy).length === 0;
        }

        function hierarchyShallowEqual(a, b) {
          if (a === b) return true;
          const aRoleIds = Object.keys(a || {});
          const bRoleIds = Object.keys(b || {});
          if (aRoleIds.length !== bRoleIds.length) return false;
          for (const roleId of aRoleIds) {
            if (!Object.prototype.hasOwnProperty.call(b, roleId)) {
              return false;
            }
            const aRole = a[roleId];
            const bRole = b[roleId];
            if (!aRole || !bRole) return false;
            if (aRole.includeAll !== bRole.includeAll) return false;
            const aLtIds = Object.keys(aRole.lts || {});
            const bLtIds = Object.keys(bRole.lts || {});
            if (aLtIds.length !== bLtIds.length) return false;
            for (const ltId of aLtIds) {
              if (
                !Object.prototype.hasOwnProperty.call(bRole.lts || {}, ltId)
              ) {
                return false;
              }
              const aLt = aRole.lts[ltId];
              const bLt = bRole.lts[ltId];
              if (!aLt || !bLt) return false;
              if (aLt.includeAll !== bLt.includeAll) return false;
              const aStIds = Object.keys(aLt.sts || {});
              const bStIds = Object.keys(bLt.sts || {});
              if (aStIds.length !== bStIds.length) return false;
              for (const stId of aStIds) {
                if (
                  !Object.prototype.hasOwnProperty.call(bLt.sts || {}, stId)
                ) {
                  return false;
                }
              }
            }
          }
          return true;
        }

        function reconcileHierarchyFilterWithData() {
          const roles = AppState.data.roles || [];
          const rolesIndex = new Map(roles.map((role) => [role.id, role]));
          const working = cloneHierarchyState(TaskFilters.hierarchy);
          Object.keys(working).forEach((roleId) => {
            const role = rolesIndex.get(roleId);
            if (!role) {
              delete working[roleId];
              return;
            }
            const roleEntry = working[roleId];
            if (roleEntry.includeAll) {
              return;
            }
            const ltIndex = new Map(
              (role.lt_goals || []).map((lt) => [lt.id, lt])
            );
            Object.keys(roleEntry.lts).forEach((ltId) => {
              const lt = ltIndex.get(ltId);
              if (!lt) {
                delete roleEntry.lts[ltId];
                return;
              }
              const ltEntry = roleEntry.lts[ltId];
              if (ltEntry.includeAll) {
                return;
              }
              const stIndex = new Set(
                (lt.st_goals || []).map((st) => st.id)
              );
              Object.keys(ltEntry.sts).forEach((stId) => {
                if (!stIndex.has(stId)) {
                  delete ltEntry.sts[stId];
                }
              });
            });
          });
          const normalized = normalizeHierarchyState(working);
          if (!hierarchyShallowEqual(TaskFilters.hierarchy, normalized)) {
            TaskFilters.hierarchy = normalized;
          }
        }

        const TaskFilters = {
          importanceMin: null,
          importanceMax: null,
          dueFrom: null,
          dueTo: null,
          state: "all",
          search: "",
          hierarchy: createHierarchyState(),
        };
        let taskSearchDraft = TaskFilters.search;

        function getAllTaskRefs() {
          const refs = [];
          AppState.data.roles.forEach((role) =>
            role.lt_goals.forEach((lt) =>
              lt.st_goals.forEach((st) =>
                st.tasks.forEach((task) => refs.push({ role, lt, st, task }))
              )
            )
          );
          return refs;
        }

        function getFilteredTaskRefs() {
          reconcileHierarchyFilterWithData();
          return getAllTaskRefs().filter(taskMatchesFilters);
        }

        function taskMatchesFilters(ref) {
          const {
            importanceMin,
            importanceMax,
            dueFrom,
            dueTo,
            state,
            search,
            hierarchy,
          } = TaskFilters;

          if (!hierarchyFilterIsEmpty(hierarchy)) {
            if (!taskMatchesHierarchyFilter(ref, hierarchy)) {
              return false;
            }
          }
          const taskImportance =
            ref.task.importance != null
              ? toImportance(ref.task.importance, 1)
              : null;

          if (importanceMin != null) {
            if (taskImportance == null || taskImportance < importanceMin) {
              return false;
            }
          }

          if (importanceMax != null) {
            if (taskImportance == null || taskImportance > importanceMax) {
              return false;
            }
          }

          const taskState = ref.task.state || DEFAULT_TASK_STATE;
          if (state !== "all" && taskState !== state) {
            return false;
          }

          const dueTimestamp = parseDateToTimestamp(ref.task.due);
          const fromTimestamp = parseDateToTimestamp(dueFrom);
          if (fromTimestamp != null) {
            if (dueTimestamp == null || dueTimestamp < fromTimestamp) {
              return false;
            }
          }

          const toTimestamp = parseDateToTimestamp(dueTo);
          if (toTimestamp != null) {
            if (dueTimestamp == null || dueTimestamp > toTimestamp) {
              return false;
            }
          }

          const query = normalizeForComparison(search);
          if (query) {
            const haystack = normalizeForComparison(
              `${ref.task.title || ""} ${ref.task.description || ""}`
            );
            if (!haystack.includes(query)) {
              return false;
            }
          }

          return true;
        }

        function taskMatchesHierarchyFilter(ref, hierarchy) {
          const roleEntry = hierarchy?.[ref.role.id];
          if (!roleEntry) return false;
          if (roleEntry.includeAll) return true;
          const ltEntry = roleEntry.lts?.[ref.lt.id];
          if (!ltEntry) return false;
          if (ltEntry.includeAll) return true;
          return Boolean(ltEntry.sts?.[ref.st.id]);
        }

        function parseDateToTimestamp(value) {
          if (!value) return null;
          const parsed = Date.parse(`${value}T00:00:00Z`);
          return Number.isNaN(parsed) ? null : parsed;
        }

        function updateTaskFilters(patch) {
          let changed = false;
          Object.entries(patch).forEach(([key, value]) => {
            if (TaskFilters[key] !== value) {
              TaskFilters[key] = value;
              changed = true;
            }
          });
          if (!changed) return;
          if (Object.prototype.hasOwnProperty.call(patch, "search")) {
            taskSearchDraft = TaskFilters.search;
          }
          rerenderTaskView();
        }

        function rerenderTaskView() {
          if (activeTab === "tasks") {
            renderTasks();
          } else if (activeTab === "dash") {
            renderDashboard();
          }
        }

        function createTaskFiltersBar({ onExport, onImport }) {
          const container = document.createElement("div");
          container.className = "controls filters";

          reconcileHierarchyFilterWithData();

          const importanceMinInput = document.createElement("input");
          importanceMinInput.type = "number";
          importanceMinInput.min = "1";
          importanceMinInput.placeholder = "≥";
          importanceMinInput.value =
            TaskFilters.importanceMin != null ? TaskFilters.importanceMin : "";
          importanceMinInput.addEventListener("change", () => {
            const value = importanceMinInput.value.trim();
            updateTaskFilters({
              importanceMin: value === "" ? null : toImportance(value, 1),
            });
          });

          const importanceMaxInput = document.createElement("input");
          importanceMaxInput.type = "number";
          importanceMaxInput.min = "1";
          importanceMaxInput.placeholder = "≤";
          importanceMaxInput.value =
            TaskFilters.importanceMax != null ? TaskFilters.importanceMax : "";
          importanceMaxInput.addEventListener("change", () => {
            const value = importanceMaxInput.value.trim();
            updateTaskFilters({
              importanceMax: value === "" ? null : toImportance(value, 1),
            });
          });

          const stateSelect = document.createElement("select");
          const stateOptions = [
            { value: "all", label: "Tutti" },
            ...TASK_STATES.map((state) => ({
              value: state.id,
              label: state.label,
            })),
          ];
          stateOptions.forEach((option) => {
            const el = document.createElement("option");
            el.value = option.value;
            el.textContent = option.label;
            stateSelect.appendChild(el);
          });
          stateSelect.value = TaskFilters.state;
          stateSelect.addEventListener("change", () =>
            updateTaskFilters({ state: stateSelect.value })
          );

          const dueFromInput = document.createElement("input");
          dueFromInput.type = "date";
          dueFromInput.value = TaskFilters.dueFrom || "";
          dueFromInput.addEventListener("change", () =>
            updateTaskFilters({ dueFrom: dueFromInput.value || null })
          );
          dueFromInput.addEventListener("input", () =>
            updateTaskFilters({ dueFrom: dueFromInput.value || null })
          );

          const dueToInput = document.createElement("input");
          dueToInput.type = "date";
          dueToInput.value = TaskFilters.dueTo || "";
          dueToInput.addEventListener("change", () =>
            updateTaskFilters({ dueTo: dueToInput.value || null })
          );
          dueToInput.addEventListener("input", () =>
            updateTaskFilters({ dueTo: dueToInput.value || null })
          );

          const searchInput = document.createElement("input");
          searchInput.type = "text";
          searchInput.placeholder = "Cerca titolo o descrizione…";
          searchInput.value = taskSearchDraft || "";
          searchInput.addEventListener("input", () => {
            taskSearchDraft = searchInput.value;
          });
          searchInput.addEventListener("keydown", (event) => {
            if (event.key === "Enter") {
              updateTaskFilters({ search: taskSearchDraft });
            }
          });

          const hierarchyControl = createHierarchyFilterControl();
          const hierarchyField = createFilterField(
            "Ruolo / LT / BT",
            hierarchyControl
          );
          hierarchyField.classList.add("filter-tree");

          container.append(
            createFilterField("Importanza da", importanceMinInput),
            createFilterField("Importanza a", importanceMaxInput),
            createFilterField("Scadenza da", dueFromInput),
            createFilterField("Scadenza a", dueToInput),
            createFilterField("Stato", stateSelect),
            hierarchyField,
            createFilterField("Ricerca", searchInput),
            button("Esporta CSV", "", () => onExport?.()),
            button("Importa CSV", "", () => onImport?.())
          );

          return container;

          function createHierarchyFilterControl() {
            const wrapper = document.createElement("div");
            wrapper.className = "hierarchy-filter";
            (AppState.data.roles || []).forEach((role) => {
              wrapper.appendChild(buildRoleNode(role));
            });
            if (!wrapper.children.length) {
              const empty = document.createElement("div");
              empty.className = "hierarchy-row is-empty";
              const span = document.createElement("span");
              span.textContent = "Nessun ruolo disponibile";
              empty.appendChild(span);
              wrapper.appendChild(empty);
            }
            return wrapper;
          }

          function buildRoleNode(role) {
            const node = document.createElement("div");
            node.className = "hierarchy-node";
            const row = document.createElement("div");
            row.className = "hierarchy-row";
            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            const roleState = getRoleSelectionState(role.id);
            checkbox.checked = roleState.checked;
            checkbox.indeterminate = roleState.indeterminate;
            checkbox.addEventListener("change", () => {
              const next = cloneHierarchyState(TaskFilters.hierarchy);
              if (checkbox.checked) {
                next[role.id] = {
                  includeAll: true,
                  lts: Object.create(null),
                };
              } else {
                delete next[role.id];
              }
              updateTaskFilters({ hierarchy: normalizeHierarchyState(next) });
            });
            row.appendChild(checkbox);
            row.appendChild(createNodeLabel(role.title || "Ruolo senza titolo"));
            row.addEventListener("click", (event) => {
              if (event.target === checkbox) return;
              if (event.target.closest(".hierarchy-row") !== row) return;
              if (checkbox.disabled) return;
              event.stopPropagation();
              checkbox.click();
            });
            node.appendChild(row);

            const ltGoals = role.lt_goals || [];
            if (ltGoals.length) {
              const children = document.createElement("div");
              children.className = "hierarchy-children";
              ltGoals.forEach((lt) => {
                children.appendChild(buildLongTermNode(role, lt));
              });
              node.appendChild(children);
            }

            return node;
          }

          function buildLongTermNode(role, lt) {
            const node = document.createElement("div");
            node.className = "hierarchy-node";
            const row = document.createElement("div");
            row.className = "hierarchy-row";
            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            const ltState = getLongTermSelectionState(role.id, lt.id);
            checkbox.checked = ltState.checked;
            checkbox.indeterminate = ltState.indeterminate;
            checkbox.disabled = ltState.disabled;
            if (!ltState.disabled) {
              checkbox.addEventListener("change", () => {
                const next = cloneHierarchyState(TaskFilters.hierarchy);
                let roleEntry = next[role.id];
                if (!roleEntry) {
                  roleEntry = {
                    includeAll: false,
                    lts: Object.create(null),
                  };
                  next[role.id] = roleEntry;
                }
                if (roleEntry.includeAll) {
                  roleEntry.includeAll = false;
                  roleEntry.lts = Object.create(null);
                }
                if (checkbox.checked) {
                  roleEntry.lts[lt.id] = {
                    includeAll: true,
                    sts: Object.create(null),
                  };
                } else {
                  delete roleEntry.lts[lt.id];
                }
                updateTaskFilters({
                  hierarchy: normalizeHierarchyState(next),
                });
              });
            }
            row.appendChild(checkbox);
            row.appendChild(createNodeLabel(lt.title || "LT senza titolo"));
            row.addEventListener("click", (event) => {
              if (event.target === checkbox) return;
              if (event.target.closest(".hierarchy-row") !== row) return;
              if (checkbox.disabled) return;
              event.stopPropagation();
              checkbox.click();
            });
            node.appendChild(row);

            const stGoals = lt.st_goals || [];
            if (stGoals.length) {
              const children = document.createElement("div");
              children.className = "hierarchy-children";
              stGoals.forEach((st) => {
                children.appendChild(buildShortTermRow(role, lt, st));
              });
              node.appendChild(children);
            }

            return node;
          }

          function buildShortTermRow(role, lt, st) {
            const row = document.createElement("div");
            row.className = "hierarchy-row";
            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            const stState = getShortTermSelectionState(role.id, lt.id, st.id);
            checkbox.checked = stState.checked;
            checkbox.disabled = stState.disabled;
            if (!stState.disabled) {
              checkbox.addEventListener("change", () => {
                const next = cloneHierarchyState(TaskFilters.hierarchy);
                let roleEntry = next[role.id];
                if (!roleEntry) {
                  roleEntry = {
                    includeAll: false,
                    lts: Object.create(null),
                  };
                  next[role.id] = roleEntry;
                }
                if (roleEntry.includeAll) {
                  roleEntry.includeAll = false;
                  roleEntry.lts = Object.create(null);
                }
                let ltEntry = roleEntry.lts[lt.id];
                if (!ltEntry) {
                  ltEntry = {
                    includeAll: false,
                    sts: Object.create(null),
                  };
                  roleEntry.lts[lt.id] = ltEntry;
                }
                if (ltEntry.includeAll) {
                  ltEntry.includeAll = false;
                  ltEntry.sts = Object.create(null);
                }
                if (checkbox.checked) {
                  ltEntry.sts[st.id] = true;
                } else {
                  delete ltEntry.sts[st.id];
                }
                updateTaskFilters({
                  hierarchy: normalizeHierarchyState(next),
                });
              });
            }
            row.appendChild(checkbox);
            row.appendChild(createNodeLabel(st.title || "BT senza titolo"));
            row.addEventListener("click", (event) => {
              if (event.target === checkbox) return;
              if (event.target.closest(".hierarchy-row") !== row) return;
              if (checkbox.disabled) return;
              event.stopPropagation();
              checkbox.click();
            });
            return row;
          }

          function createNodeLabel(text) {
            const label = document.createElement("span");
            label.textContent = text;
            return label;
          }

          function getRoleSelectionState(roleId) {
            const entry = TaskFilters.hierarchy[roleId];
            if (!entry) {
              return { checked: false, indeterminate: false };
            }
            if (entry.includeAll) {
              return { checked: true, indeterminate: false };
            }
            return {
              checked: false,
              indeterminate: Object.keys(entry.lts || {}).length > 0,
            };
          }

          function getLongTermSelectionState(roleId, ltId) {
            const roleEntry = TaskFilters.hierarchy[roleId];
            if (!roleEntry) {
              return { checked: false, indeterminate: false, disabled: false };
            }
            if (roleEntry.includeAll) {
              return { checked: true, indeterminate: false, disabled: true };
            }
            const ltEntry = (roleEntry.lts || {})[ltId];
            if (!ltEntry) {
              return {
                checked: false,
                indeterminate: false,
                disabled: false,
              };
            }
            if (ltEntry.includeAll) {
              return { checked: true, indeterminate: false, disabled: false };
            }
            return {
              checked: false,
              indeterminate: Object.keys(ltEntry.sts || {}).length > 0,
              disabled: false,
            };
          }

          function getShortTermSelectionState(roleId, ltId, stId) {
            const roleEntry = TaskFilters.hierarchy[roleId];
            if (!roleEntry) {
              return { checked: false, disabled: false };
            }
            if (roleEntry.includeAll) {
              return { checked: true, disabled: true };
            }
            const ltEntry = (roleEntry.lts || {})[ltId];
            if (!ltEntry) {
              return { checked: false, disabled: false };
            }
            if (ltEntry.includeAll) {
              return { checked: true, disabled: true };
            }
            const sts = ltEntry.sts || {};
            return {
              checked: Boolean(sts[stId]),
              disabled: false,
            };
          }
        }

        function createFilterField(label, control) {
          const wrapper = document.createElement("label");
          wrapper.className = "filter-field";
          const span = document.createElement("span");
          span.textContent = label;
          wrapper.append(span, control);
          return wrapper;
        }

        function selectRole(selectedId) {
          const select = document.createElement("select");
          AppState.data.roles.forEach((role) => {
            const option = document.createElement("option");
            option.value = role.id;
            option.textContent = role.title;
            select.appendChild(option);
          });
          if (selectedId) select.value = selectedId;
          return select;
        }

        function selectLongTerm(roleId, selectedId) {
          const select = document.createElement("select");
          const role = AppState.data.roles.find((r) => r.id === roleId);
          (role?.lt_goals || []).forEach((goal) => {
            const option = document.createElement("option");
            option.value = goal.id;
            option.textContent = goal.title;
            select.appendChild(option);
          });
          if (selectedId) select.value = selectedId;
          return select;
        }

        function createTaskStateSelect(task) {
          const select = document.createElement("select");
          select.className = "task-state-select";
          TASK_STATES.forEach((state) => {
            const option = document.createElement("option");
            option.value = state.id;
            option.textContent = state.label;
            select.appendChild(option);
          });
          select.value = getTaskStateId(task.state);
          updateTaskStateSelectStyle(select);
          select.addEventListener("change", () => {
            task.state = select.value;
            updateTaskStateSelectStyle(select);
            AppState.persist();
          });
          return select;
        }

        function updateTaskStateSelectStyle(select) {
          const config = getTaskStateConfig(select.value);
          if (!config) return;
          select.style.setProperty("--state-color", config.color);
          select.style.borderColor = config.color;
          select.style.boxShadow = `0 0 0 1px ${config.color} inset`;
          select.title = config.label;
        }

        function createBadge(text) {
          const badge = document.createElement("span");
          badge.className = "badge";
          badge.textContent = text;
          return badge;
        }

        function truncateText(value, max) {
          const text = (value || "").trim();
          if (!text) return "—";
          return text.length > max ? `${text.slice(0, max - 1)}…` : text;
        }

        function confirmDelete(message) {
          return window.confirm(message || "Sei sicuro? Questa azione è irreversibile.");
        }

        function makeTable(columns, rows) {
          const wrapper = document.createElement("div");
          wrapper.style.overflowX = "auto";

          const table = document.createElement("table");
          const thead = document.createElement("thead");
          const headerRow = document.createElement("tr");

          let sortIndex = -1;
          let sortDir = 1;

          function defaultComparator(a, b) {
            if (a == null && b == null) return 0;
            if (a == null) return -1;
            if (b == null) return 1;
            if (a > b) return 1;
            if (a < b) return -1;
            return 0;
          }

          function applySort() {
            if (sortIndex < 0) return;
            const column = columns[sortIndex];
            const comparator = column.sort || ((rowA, rowB) => {
              const key = column.key;
              const a = typeof key === "function" ? key(rowA) : undefined;
              const b = typeof key === "function" ? key(rowB) : undefined;
              return defaultComparator(a, b);
            });
            rows.sort((a, b) => sortDir * comparator(a, b));
          }

          columns.forEach((column, idx) => {
            const th = document.createElement("th");
            th.textContent = column.label;
            if (column.key || column.sort) {
              th.classList.add("sortable");
              th.addEventListener("click", () => {
                if (sortIndex === idx) {
                  sortDir = -sortDir;
                } else {
                  sortIndex = idx;
                  sortDir = 1;
                }

                [...headerRow.children].forEach((el, headerIdx) => {
                  el.classList.remove("asc", "desc");
                  if (headerIdx === sortIndex) {
                    el.classList.add(sortDir === 1 ? "asc" : "desc");
                  }
                });

                applySort();
                renderBody();
              });
            }
            headerRow.appendChild(th);
          });

          thead.appendChild(headerRow);
          table.appendChild(thead);

          const tbody = document.createElement("tbody");

          function renderBody() {
            tbody.innerHTML = "";
            rows.forEach((row) => {
              const tr = document.createElement("tr");
              columns.forEach((column) => {
                const td = document.createElement("td");
                td.appendChild(column.render(row));
                tr.appendChild(td);
              });
              tbody.appendChild(tr);
            });
          }

          applySort();
          renderBody();

          table.appendChild(tbody);
          wrapper.appendChild(table);
          return wrapper;
        }

        // =============================================================
        // Tab: Ruoli
        // =============================================================
        function renderRoles() {
          dom.view.innerHTML = "";
          const rows = AppState.data.roles.slice();

          const table = makeTable(
            [
              {
                label: "Titolo",
                key: (role) => (role.title || "").toLowerCase(),
                render: (role) =>
                  inputText(role.title, "Titolo", (value) => {
                    role.title = value;
                    AppState.persist();
                  }),
              },
              {
                label: "Importanza (≥1)",
                key: (role) => role.importance || 0,
                  render: (role) => {
                      const el = inputInteger(role.importance, (value) => {
                          role.importance = toImportance(value ?? 1); // solo stato
                      });
                      const commit = () => {
                          cascadeFromRole(role);
                          AppState.persist();
                          render();
                      };
                      el.addEventListener("blur", commit);
                      el.addEventListener("change", commit); // per sicurezza
                      el.addEventListener("keydown", (e) => { if (e.key === "Enter") el.blur(); });
                      return el;
                  },
              },
              {
                label: "Azioni",
                render: (role) => {
                  const container = document.createElement("div");
                  container.className = "controls";
                  container.append(
                    button("+ LT", "", () => {
                      role.lt_goals.push(
                        createLongTerm(
                          "Nuovo obiettivo LT",
                          "",
                          3,
                          DateUtils.addDays(90)
                        )
                      );
                      AppState.persist();
                      render();
                    }),
                    button("Elimina", "", () => {
                      if (!confirmDelete("Eliminare ruolo e tutti i figli?"))
                        return;
                      AppState.data.roles = AppState.data.roles.filter(
                        (candidate) => candidate.id !== role.id
                      );
                      AppState.persist();
                      render();
                    })
                  );
                  return container;
                },
              },
            ],
            rows
          );

          const toolbar = document.createElement("div");
          toolbar.className = "controls";
          toolbar.appendChild(
            button("+ Ruolo", "primary", () => {
              AppState.data.roles.push(createRole("Nuovo ruolo", 3));
              AppState.persist();
              render();
            })
          );

          dom.view.append(toolbar, table);
        }

        // =============================================================
        // Tab: Obiettivi Lungo Termine (LT)
        // =============================================================
        function renderLongTermGoals() {
          dom.view.innerHTML = "";
          const rows = [];
          AppState.data.roles.forEach((role) =>
            role.lt_goals.forEach((lt) => rows.push({ role, lt }))
          );

          const table = makeTable(
            [
              {
                label: "Ruolo",
                key: (row) => (row.role.title || "").toLowerCase(),
                render: (row) => {
                  const select = selectRole(row.role.id);
                  select.addEventListener("input", () => {
                    const from = row.role;
                    const to = AppState.data.roles.find(
                      (candidate) => candidate.id === select.value
                    );
                    if (!to || from.id === to.id) return;
                    from.lt_goals = from.lt_goals.filter(
                      (goal) => goal.id !== row.lt.id
                    );
                    to.lt_goals.push(row.lt);
                    row.role = to;
                    AppState.persist();
                    render();
                  });
                  return select;
                },
              },
              {
                label: "Titolo",
                key: (row) => (row.lt.title || "").toLowerCase(),
                render: (row) =>
                  inputText(row.lt.title, "Titolo", (value) => {
                    row.lt.title = value;
                    AppState.persist();
                  }),
              },
              {
                label: "Descrizione",
                render: (row) =>
                  textArea(row.lt.description, (value) => {
                    row.lt.description = value;
                    AppState.persist();
                  }),
              },
              {
                label: "Importanza (≥1)",
                key: (row) => row.lt.importance || 0,
                render: (row) =>
                    (() => {
                        const el = inputInteger(row.lt.importance, (value) => {
                            row.lt.importance = toImportance(value ?? 1);
                        });
                        const commit = () => {
                            clampChildToParent(row.lt, row.role);
                            cascadeFromRole(row.role);
                            AppState.persist();
                            render();
                        };
                        el.addEventListener("blur", commit);
                        el.addEventListener("change", commit);
                        el.addEventListener("keydown", (e) => { if (e.key === "Enter") el.blur(); });
                        return el;
                    })(),
              },
              {
                label: "Scadenza",
                key: (row) => row.lt.due || "",
                render: (row) =>
                    (() => {
                        const el = inputDate(row.lt.due, (value) => {
                            row.lt.due = value || DateUtils.today();
                            }, { readOnly: false }); // ← Cambiato a false
                        const commit = () => {
                            clampChildToParent(row.lt, row.role);
                            cascadeFromRole(row.role);
                            AppState.persist();
                            render();
                        };
                        el.addEventListener("blur", commit);
                        el.addEventListener("change", commit);
                        return el;
                    })(),
              }
              ,
              {
                label: "Azioni",
                render: (row) => {
                  const container = document.createElement("div");
                  container.className = "controls";
                  container.append(
                    button("+ BT", "", () => {
                      row.lt.st_goals.push(
                        createShortTerm("Nuovo obiettivo BT", "", null, null)
                      );
                      AppState.persist();
                      render();
                    }),
                    button("Elimina", "", () => {
                      if (
                        !confirmDelete(
                          "Eliminare obiettivo LT e tutti i figli?"
                        )
                      )
                        return;
                      row.role.lt_goals = row.role.lt_goals.filter(
                        (candidate) => candidate.id !== row.lt.id
                      );
                      AppState.persist();
                      render();
                    })
                  );
                  return container;
                },
              },
            ],
            rows
          );

          const toolbar = document.createElement("div");
          toolbar.className = "controls";
          toolbar.appendChild(
            button("+ Obiettivo LT", "primary", () => {
              if (!AppState.data.roles.length) {
                alert("Prima crea almeno un Ruolo.");
                return;
              }
              AppState.data.roles[0].lt_goals.push(
                createLongTerm(
                  "Nuovo obiettivo LT",
                  "",
                  3,
                  DateUtils.addDays(120)
                )
              );
              AppState.persist();
              render();
            })
          );

          dom.view.append(toolbar, table);
        }

        // =============================================================
        // Tab: Obiettivi Breve Termine (ST)
        // =============================================================
        function renderShortTermGoals() {
          dom.view.innerHTML = "";
          const rows = [];
          AppState.data.roles.forEach((role) =>
            role.lt_goals.forEach((lt) =>
              lt.st_goals.forEach((st) => rows.push({ role, lt, st }))
            )
          );

          const table = makeTable(
            [
              {
                label: "Ruolo",
                key: (row) => (row.role.title || "").toLowerCase(),
                render: (row) => {
                  const select = selectRole(row.role.id);
                  select.addEventListener("input", () => {
                    const newRole = AppState.data.roles.find(
                      (candidate) => candidate.id === select.value
                    );
                    if (!newRole || newRole.id === row.role.id) return;
                    row.lt.st_goals = row.lt.st_goals.filter(
                      (candidate) => candidate.id !== row.st.id
                    );
                    if (!newRole.lt_goals.length) {
                      newRole.lt_goals.push(
                        createLongTerm(
                          "Auto creato",
                          "",
                          row.lt.importance,
                          row.lt.due
                        )
                      );
                    }
                    const targetLT = newRole.lt_goals[0];
                    targetLT.st_goals.push(row.st);
                    row.role = newRole;
                    row.lt = targetLT;
                    clampChildToParent(row.st, row.lt);
                    AppState.persist();
                    render();
                  });
                  return select;
                },
              },
              {
                label: "LT",
                key: (row) => (row.lt.title || "").toLowerCase(),
                render: (row) => {
                  const select = selectLongTerm(row.role.id, row.lt.id);
                  select.addEventListener("input", () => {
                    const target = row.role.lt_goals.find(
                      (candidate) => candidate.id === select.value
                    );
                    if (!target) return;
                    row.lt.st_goals = row.lt.st_goals.filter(
                      (candidate) => candidate.id !== row.st.id
                    );
                    target.st_goals.push(row.st);
                    row.lt = target;
                    clampChildToParent(row.st, row.lt);
                    AppState.persist();
                    render();
                  });
                  return select;
                },
              },
              {
                label: "Titolo",
                key: (row) => (row.st.title || "").toLowerCase(),
                render: (row) =>
                  inputText(row.st.title, "Titolo", (value) => {
                    row.st.title = value;
                    AppState.persist();
                  }),
              },
              {
                label: "Descrizione",
                render: (row) =>
                  textArea(row.st.description, (value) => {
                    row.st.description = value;
                    AppState.persist();
                  }),
              },
              {
                label: "Importanza (ereditata se vuota)",
                key: (row) =>
                  effectiveImportance(row.st, row.lt.importance ?? 1) || 0,
                    render: (row) => {
                        const el = inputInteger(row.st.importance, (value) => {
                            row.st.importance = value;
                        });
                        el.addEventListener("blur", () => {
                            clampChildToParent(row.st, row.lt);
                            AppState.persist();
                            render();
                        });
                        return el;
                    }
              },
              {
                label: "Scadenza (ereditata se vuota)",
                key: (row) => effectiveDueDate(row.st, row.lt.due) || "",
                render: (row) => {
                    const el = inputDate(row.st.due, (value) => {
                        row.st.due = value;
                        }, { readOnly: false }); // ← Cambiato a false
                    el.addEventListener("blur", () => {
                        clampChildToParent(row.st, row.lt);
                        AppState.persist();
                        render();
                    });
                    return el;
                }
              }
              ,
              {
                label: "Azioni",
                render: (row) => {
                  const container = document.createElement("div");
                  container.className = "controls";
                  container.append(
                    button("+ Attività", "", () => {
                      row.st.tasks.push(
                        createTask("Nuova attività", "", null, null)
                      );
                      AppState.persist();
                      render();
                    }),
                    button("Elimina", "", () => {
                      if (!confirmDelete("Eliminare obiettivo BT?")) return;
                      row.lt.st_goals = row.lt.st_goals.filter(
                        (candidate) => candidate.id !== row.st.id
                      );
                      AppState.persist();
                      render();
                    })
                  );
                  return container;
                },
              },
            ],
            rows
          );

          const toolbar = document.createElement("div");
          toolbar.className = "controls";
          toolbar.appendChild(
            button("+ Obiettivo BT", "primary", () => {
              if (!AppState.data.roles.length) {
                alert("Crea prima Ruolo > LT");
                return;
              }
              const role = AppState.data.roles[0];
              if (!role.lt_goals.length) {
                role.lt_goals.push(
                  createLongTerm(
                    "Nuovo obiettivo LT",
                    "",
                    3,
                    DateUtils.addDays(120)
                  )
                );
              }
              role.lt_goals[0].st_goals.push(
                createShortTerm("Nuovo obiettivo BT", "", null, null)
              );
              AppState.persist();
              render();
            })
          );

          dom.view.append(toolbar, table);
        }

        // =============================================================
        // Tab: Attività
        // =============================================================
        function renderTasks() {
          dom.view.innerHTML = "";
          const rows = getFilteredTaskRefs();

          const filtersBar = createTaskFiltersBar({
            onExport: () => exportTasksToCsv(getFilteredTaskRefs()),
            onImport: () => requestTaskCsvImport(),
          });

          const table = makeTable(
            [
              {
                label: "Ruolo",
                key: (row) => (row.role.title || "").toLowerCase(),
                render: (row) => {
                  const select = selectRole(row.role.id);
                  select.addEventListener("input", () => {
                    const newRole = AppState.data.roles.find(
                      (candidate) => candidate.id === select.value
                    );
                    if (!newRole || newRole.id === row.role.id) return;
                    row.st.tasks = row.st.tasks.filter(
                      (candidate) => candidate.id !== row.task.id
                    );
                    if (!newRole.lt_goals.length) {
                      newRole.lt_goals.push(
                        createLongTerm(
                          "Auto creato",
                          "",
                          row.lt.importance,
                          row.lt.due
                        )
                      );
                    }
                    const targetLT = newRole.lt_goals[0];
                    if (!targetLT.st_goals.length) {
                      targetLT.st_goals.push(
                        createShortTerm(
                          "Auto creato",
                          "",
                          row.st.importance,
                          row.st.due
                        )
                      );
                    }
                    const targetST = targetLT.st_goals[0];
                    targetST.tasks.push(row.task);
                    row.role = newRole;
                    row.lt = targetLT;
                    row.st = targetST;
                    clampChildToParent(row.task, row.st.due ? row.st : row.lt);
                    AppState.persist();
                    render();
                  });
                  return select;
                },
              },
              {
                label: "LT",
                key: (row) => (row.lt.title || "").toLowerCase(),
                render: (row) => {
                  const select = selectLongTerm(row.role.id, row.lt.id);
                  select.addEventListener("input", () => {
                    const target = row.role.lt_goals.find(
                      (candidate) => candidate.id === select.value
                    );
                    if (!target) return;
                    row.st.tasks = row.st.tasks.filter(
                      (candidate) => candidate.id !== row.task.id
                    );
                    if (!target.st_goals.length) {
                      target.st_goals.push(
                        createShortTerm(
                          "Auto creato",
                          "",
                          row.st.importance,
                          row.st.due
                        )
                      );
                    }
                    const targetST = target.st_goals[0];
                    targetST.tasks.push(row.task);
                    row.lt = target;
                    row.st = targetST;
                    clampChildToParent(row.task, row.st.due ? row.st : row.lt);
                    AppState.persist();
                    render();
                  });
                  return select;
                },
              },
              {
                label: "BT",
                key: (row) => (row.st.title || "").toLowerCase(),
                render: (row) => {
                  const select = document.createElement("select");
                  row.lt.st_goals.forEach((st) => {
                    const option = document.createElement("option");
                    option.value = st.id;
                    option.textContent = st.title;
                    select.appendChild(option);
                  });
                  select.value = row.st.id;
                  select.addEventListener("input", () => {
                    const target = row.lt.st_goals.find(
                      (candidate) => candidate.id === select.value
                    );
                    if (!target) return;
                    row.st.tasks = row.st.tasks.filter(
                      (candidate) => candidate.id !== row.task.id
                    );
                    target.tasks.push(row.task);
                    row.st = target;
                    clampChildToParent(row.task, row.st.due ? row.st : row.lt);
                    AppState.persist();
                    render();
                  });
                  return select;
                },
              },
              {
                label: "Titolo",
                key: (row) => (row.task.title || "").toLowerCase(),
                render: (row) =>
                  inputText(row.task.title, "Titolo", (value) => {
                    row.task.title = value;
                    AppState.persist();
                  }),
              },
              {
                label: "Descrizione",
                render: (row) =>
                  textArea(row.task.description, (value) => {
                    row.task.description = value;
                    AppState.persist();
                  }),
              },
              {
                label: "Stato",
                key: (row) =>
                  getTaskStateConfig(row.task.state).label.toLowerCase(),
                render: (row) => createTaskStateSelect(row.task),
              },
              {
                label: "Importanza (ereditata se vuota)",
                key: (row) =>
                  effectiveImportance(
                    row.task,
                    effectiveImportance(row.st, row.lt.importance)
                  ) || 0,
                  render: (row) => {
                      return inputInteger(row.task.importance, (value) => {
                          row.task.importance = value;
                          clampChildToParent(row.task, row.st.due ? row.st : row.lt);
                          AppState.persist();
                      });
              }
              },
                {
                    label: "Scadenza (ereditata se vuota)",
                    key: (row) =>
                        effectiveDueDate(
                            row.task,
                            effectiveDueDate(row.st, row.lt.due)
                        ) || "",
                    render: (row) => {
                        const el = inputDate(row.task.due, (value) => {
                            row.task.due = value;
                        }, { readOnly: false }); // ← Cambiato a false
                        el.addEventListener("blur", () => {
                            clampChildToParent(row.task, row.st.due ? row.st : row.lt);
                            AppState.persist();
                            render();
                        });
                        return el;
                    }
                }
              ,
              {
                label: "Azioni",
                render: (row) => {
                  const container = document.createElement("div");
                  container.className = "controls";
                  container.appendChild(
                    button("Elimina", "", () => {
                      if (!confirmDelete("Eliminare attività?")) return;
                      row.st.tasks = row.st.tasks.filter(
                        (candidate) => candidate.id !== row.task.id
                      );
                      AppState.persist();
                      render();
                    })
                  );
                  return container;
                },
              },
            ],
            rows
          );

          const toolbar = document.createElement("div");
          toolbar.className = "controls";
          toolbar.appendChild(
            button("+ Attività", "primary", () => {
              if (!AppState.data.roles.length) {
                alert("Crea prima Ruolo > LT > BT");
                return;
              }
              const role = AppState.data.roles[0];
              if (!role.lt_goals.length) {
                role.lt_goals.push(
                  createLongTerm(
                    "Nuovo LT",
                    "",
                    3,
                    DateUtils.addDays(120)
                  )
                );
              }
              const lt = role.lt_goals[0];
              if (!lt.st_goals.length) {
                lt.st_goals.push(createShortTerm("Nuovo BT", "", null, null));
              }
              lt.st_goals[0].tasks.push(
                createTask("Nuova attività", "", null, null)
              );
              AppState.persist();
              render();
            })
          );

          dom.view.append(filtersBar, toolbar, table);
        }

        // =============================================================
        // Tab: Dashboard
        // =============================================================
        function renderDashboard() {
          dom.view.innerHTML = "";
          const filtersBar = createTaskFiltersBar({
            onExport: () => exportTasksToCsv(getFilteredTaskRefs()),
            onImport: () => requestTaskCsvImport(),
          });
          const kanban = document.createElement("div");
          kanban.className = "kanban";

          const columns = new Map();
          TASK_STATES.forEach((state) => {
            const column = createKanbanColumn(state);
            columns.set(state.id, column);
            kanban.appendChild(column.element);
          });

          getFilteredTaskRefs().forEach(({ role, lt, st, task }) => {
            const stateId = getTaskStateId(task.state);
            const column = columns.get(stateId);
            if (!column) return;
            if (column.placeholder.isConnected) {
              column.body.removeChild(column.placeholder);
            }
            column.body.appendChild(createKanbanCard({ role, lt, st, task }));
            column.count += 1;
          });

          columns.forEach((column) => {
            if (!column.count && !column.placeholder.isConnected) {
              column.body.appendChild(column.placeholder);
            }
            column.countEl.textContent = String(column.count);
          });

          dom.view.append(filtersBar, kanban);
        }

        function createKanbanColumn(state) {
          const column = document.createElement("section");
          column.className = "kanban-column";
          column.dataset.state = state.id;

          const header = document.createElement("div");
          header.className = "kanban-column-header";
          const title = document.createElement("span");
          title.textContent = state.label;
          const count = document.createElement("span");
          count.className = "kanban-column-count";
          count.textContent = "0";
          header.append(title, count);

          const body = document.createElement("div");
          body.className = "kanban-column-body";
          body.dataset.state = state.id;

          const placeholder = document.createElement("p");
          placeholder.className = "kanban-column-placeholder";
          placeholder.textContent = "Nessuna attività. Trascina qui per cambiare stato.";
          body.appendChild(placeholder);

          setupDropZone(column, body, state.id);

          column.append(header, body);

          return {
            element: column,
            body,
            countEl: count,
            placeholder,
            count: 0,
          };
        }

        function setupDropZone(columnElement, dropTarget, stateId) {
          dropTarget.addEventListener("dragenter", (event) => {
            event.preventDefault();
            columnElement.classList.add("dragover");
          });

          dropTarget.addEventListener("dragover", (event) => {
            event.preventDefault();
            event.dataTransfer.dropEffect = "move";
            columnElement.classList.add("dragover");
          });

          dropTarget.addEventListener("dragleave", (event) => {
            const destination = event.relatedTarget;
            if (!destination || !columnElement.contains(destination)) {
              columnElement.classList.remove("dragover");
            }
          });

          dropTarget.addEventListener("drop", (event) => {
            event.preventDefault();
            columnElement.classList.remove("dragover");
            const payload = event.dataTransfer.getData("text/plain");
            if (!payload) return;
            let identifiers;
            try {
              identifiers = JSON.parse(payload);
            } catch (error) {
              console.warn("Payload drop non valido", error);
              return;
            }
            if (!identifiers) return;
            const ref = findTaskRef(identifiers);
            if (!ref) return;
            const nextState = stateId;
            if (ref.task.state === nextState) return;
            ref.task.state = nextState;
            normalizeTask(ref.task);
            AppState.persist();
            render();
          });
        }

        function createKanbanCard({ role, lt, st, task }) {
          const config = getTaskStateConfig(task.state);
          const card = document.createElement("article");
          card.className = "kanban-card";
          card.draggable = true;
          card.dataset.roleId = role.id;
          card.dataset.ltId = lt.id;
          card.dataset.stId = st.id;
          card.dataset.taskId = task.id;
          card.style.borderTop = `3px solid ${config.color}`;

          card.addEventListener("dragstart", (event) => {
            event.dataTransfer.effectAllowed = "move";
            event.dataTransfer.setData(
              "text/plain",
              JSON.stringify({
                roleId: role.id,
                ltId: lt.id,
                stId: st.id,
                taskId: task.id,
              })
            );
            card.classList.add("dragging");
          });

          card.addEventListener("dragend", () => {
            card.classList.remove("dragging");
          });

          const hierarchy = document.createElement("div");
          hierarchy.className = "kanban-card-hierarchy";
          hierarchy.textContent = [role.title, lt.title, st.title]
            .map((value) => value || "—")
            .join(" › ");

          const title = document.createElement("div");
          title.className = "title";
          title.textContent = task.title || "(Senza titolo)";

          const description = document.createElement("div");
          description.className = "description";
          description.textContent = truncateText(task.description, 140);

          const importance = effectiveImportance(
            task,
            effectiveImportance(st, lt.importance)
          );
          const due = effectiveDueDate(task, effectiveDueDate(st, lt.due));
          const meta = document.createElement("div");
          meta.className = "kanban-card-meta";
          meta.append(
            createBadge(`Imp: ${importance ?? "-"}`),
            createBadge(`Scadenza: ${due || "-"}`)
          );

          card.append(hierarchy, title, description, meta);
          return card;
        }

        // =============================================================
        // Factory function per creare nuovi elementi del dominio
        // =============================================================
        function createRole(title, importance) {
          return {
            id: AppState.nextId(),
            title,
            importance: toImportance(importance, 1),
            lt_goals: [],
          };
        }

        function createLongTerm(title, description, importance, due) {
          return {
            id: AppState.nextId(),
            title,
            description: description || "",
            importance: toImportance(importance, 1),
            due: due || DateUtils.today(),
            st_goals: [],
          };
        }

        function createShortTerm(title, description, importance, due) {
          return {
            id: AppState.nextId(),
            title,
            description: description || "",
            importance: toImportanceOrNull(importance),
            due: due || null,
            tasks: [],
          };
        }

        function createTask(title, description, importance, due) {
          const task = {
            id: AppState.nextId(),
            title,
            description: description || "",
            importance: toImportanceOrNull(importance),
            due: due || null,
            state: DEFAULT_TASK_STATE,
          };
          normalizeTask(task);
          return task;
        }

        // =============================================================
        // Export / Import CSV attività
        // =============================================================
        function exportTasksToCsv(taskRefs) {
          const lines = [TASK_CSV_HEADERS.join(",")];
          taskRefs.forEach(({ role, lt, st, task }) => {
            lines.push(
              [
                role.title || "",
                lt.title || "",
                st.title || "",
                task.title || "",
                task.description || "",
                task.importance ?? "",
                task.due || "",
                getTaskStateId(task.state),
              ]
                .map(escapeCsvValue)
                .join(",")
            );
          });

          const blob = new Blob([lines.join("\r\n")], {
            type: "text/csv;charset=utf-8;",
          });
          const link = document.createElement("a");
          link.href = URL.createObjectURL(blob);
          link.download = TASK_CSV_FILE_NAME;
          document.body.appendChild(link);
          link.click();
          link.remove();
          URL.revokeObjectURL(link.href);
        }

        function escapeCsvValue(value) {
          if (value == null) return "";
          const text = String(value);
          if (/[",\n\r]/.test(text)) {
            return `"${text.replace(/"/g, '""')}"`;
          }
          return text;
        }

        function importTasksFromCsvContent(content) {
          const rows = parseCsv(content);
          if (!rows.length) {
            throw new Error("CSV vuoto");
          }

          const headerRow = rows[0];
          const indexMap = buildCsvIndexMap(headerRow);
          const missingColumns = Object.keys(TASK_CSV_COLUMN_LABELS).filter(
            (key) => indexMap[key] === -1
          );
          if (missingColumns.length) {
            const labels = missingColumns
              .map((key) => TASK_CSV_COLUMN_LABELS[key])
              .join(", ");
            throw new Error(`Colonne mancanti nel CSV: ${labels}`);
          }

          let imported = 0;
          const touchedRoles = new Set();

          for (let i = 1; i < rows.length; i += 1) {
            const row = rows[i];
            if (!row || !row.length) continue;
            const normalizedRow = headerRow.map((_, idx) => row[idx] ?? "");
            if (normalizedRow.every((value) => !value.trim())) continue;

            const roleTitle = normalizedRow[indexMap.role];
            const ltTitle = normalizedRow[indexMap.lt];
            const stTitle = normalizedRow[indexMap.st];
            const title = normalizedRow[indexMap.title] || "Attività importata";
            const description = normalizedRow[indexMap.description] || "";
            const rawImportance = normalizedRow[indexMap.importance].trim();
            let importance = null;
            if (rawImportance) {
              const parsedImportance = Number.parseInt(rawImportance, 10);
              if (!Number.isNaN(parsedImportance)) {
                importance = parsedImportance;
              }
            }
            const due = sanitizeCsvDate(normalizedRow[indexMap.due]);
            const state = resolveTaskStateFromCsv(normalizedRow[indexMap.state]);

            const role = ensureRoleForImport(roleTitle);
            const lt = ensureLongTermForImport(role, ltTitle, due);
            const st = ensureShortTermForImport(lt, stTitle, due);

            const task = createTask(title, description, importance, due);
            task.state = state;
            normalizeTask(task);
            clampChildToParent(task, st.due ? st : lt);
            st.tasks.push(task);
            imported += 1;
            touchedRoles.add(role);
          }

          touchedRoles.forEach((role) => cascadeFromRole(role));
          if (!imported) {
            throw new Error("Nessuna attività trovata nel CSV");
          }
          return imported;
        }

        function buildCsvIndexMap(headerRow) {
          const normalized = headerRow.map(normalizeForComparison);
          const map = {};
          Object.entries(TASK_CSV_COLUMN_ALIASES).forEach(([key, aliases]) => {
            map[key] = normalized.findIndex((value) =>
              aliases.some((alias) => normalizeForComparison(alias) === value)
            );
          });
          return map;
        }

        function parseCsv(content) {
          const rows = [];
          let current = [];
          let currentValue = "";
          let inQuotes = false;

          for (let i = 0; i < content.length; i += 1) {
            const char = content[i];
            if (inQuotes) {
              if (char === '"') {
                if (content[i + 1] === '"') {
                  currentValue += '"';
                  i += 1;
                } else {
                  inQuotes = false;
                }
              } else {
                currentValue += char;
              }
              continue;
            }

            if (char === '"') {
              inQuotes = true;
            } else if (char === ',') {
              current.push(currentValue);
              currentValue = "";
            } else if (char === '\r') {
              // ignore
            } else if (char === '\n') {
              current.push(currentValue);
              rows.push(current);
              current = [];
              currentValue = "";
            } else {
              currentValue += char;
            }
          }

          current.push(currentValue);
          if (current.length > 1 || current[0] !== "") {
            rows.push(current);
          }
          return rows;
        }

        function normalizeForComparison(value) {
          return value
            ? value
                .toString()
                .trim()
                .toLowerCase()
                .normalize("NFD")
                .replace(/\p{Diacritic}/gu, "")
            : "";
        }

        function resolveTaskStateFromCsv(value) {
          const normalized = normalizeForComparison(value);
          if (!normalized) return DEFAULT_TASK_STATE;
          for (const state of TASK_STATES) {
            if (normalizeForComparison(state.id) === normalized) {
              return state.id;
            }
            if (normalizeForComparison(state.label) === normalized) {
              return state.id;
            }
          }
          return DEFAULT_TASK_STATE;
        }

        function sanitizeCsvDate(value) {
          const trimmed = (value || "").trim();
          if (!trimmed) return null;
          if (/^\d{4}-\d{2}-\d{2}$/.test(trimmed)) return trimmed;
          return null;
        }

        function ensureRoleForImport(title) {
          const finalTitle = title && title.trim() ? title.trim() : "Ruolo importato";
          const normalizedTitle = normalizeForComparison(finalTitle);
          let role = AppState.data.roles.find(
            (candidate) => normalizeForComparison(candidate.title) === normalizedTitle
          );
          if (!role) {
            role = createRole(finalTitle, 3);
            AppState.data.roles.push(role);
          }
          return role;
        }

        function ensureLongTermForImport(role, title, dueHint) {
          const finalTitle = title && title.trim()
            ? title.trim()
            : "Obiettivo LT importato";
          const normalizedTitle = normalizeForComparison(finalTitle);
          let lt = role.lt_goals.find(
            (candidate) => normalizeForComparison(candidate.title) === normalizedTitle
          );
          if (!lt) {
            const due = sanitizeCsvDate(dueHint) || DateUtils.addDays(365);
            lt = createLongTerm(finalTitle, "", role.importance, due);
            clampChildToParent(lt, role);
            role.lt_goals.push(lt);
          }
          return lt;
        }

        function ensureShortTermForImport(lt, title, dueHint) {
          const finalTitle = title && title.trim()
            ? title.trim()
            : "Obiettivo BT importato";
          const normalizedTitle = normalizeForComparison(finalTitle);
          let st = lt.st_goals.find(
            (candidate) => normalizeForComparison(candidate.title) === normalizedTitle
          );
          if (!st) {
            const due = sanitizeCsvDate(dueHint) || null;
            st = createShortTerm(finalTitle, "", null, due);
            clampChildToParent(st, lt);
            lt.st_goals.push(st);
          }
          return st;
        }

        // =============================================================
        // Export / Import JSON
        // =============================================================
        dom.exportBtn.addEventListener("click", () => {
          const blob = new Blob([JSON.stringify(AppState.data, null, 2)], {
            type: "application/json",
          });
          const link = document.createElement("a");
          link.href = URL.createObjectURL(blob);
          link.download = DEFAULT_FILE_NAME;
          document.body.appendChild(link);
          link.click();
          link.remove();
          URL.revokeObjectURL(link.href);
        });

        dom.importBtn.addEventListener("click", () => dom.filePicker.click());

        dom.filePicker.addEventListener("change", async (event) => {
          const file = event.target.files?.[0];
          if (!file) return;
          try {
            const content = await file.text();
            const parsed = JSON.parse(content);
            if (!validate(parsed)) {
              alert("JSON non valido");
              return;
            }
            AppState.replace(parsed);
            render();
          } catch (error) {
            alert(`Errore import: ${error.message}`);
          } finally {
            dom.filePicker.value = "";
          }
        });

        // =============================================================
        // File System Access API
        // =============================================================
        const FileSystem = {
          supported:
            "showSaveFilePicker" in window && "showOpenFilePicker" in window,
        };

        dom.saveFileBtn.addEventListener("click", async () => {
          if (!FileSystem.supported) {
            alert(
              "Il tuo browser non supporta il salvataggio diretto. Usa Esporta JSON."
            );
            return;
          }
          try {
            if (!AppState.currentFileHandle) {
              AppState.currentFileHandle = await window.showSaveFilePicker({
                suggestedName: DEFAULT_FILE_NAME,
                types: [
                  {
                    description: "JSON",
                    accept: { "application/json": [".json"] },
                  },
                ],
              });
            }
            const writable = await AppState.currentFileHandle.createWritable();
            await writable.write(JSON.stringify(AppState.data, null, 2));
            await writable.close();
            alert("Salvato ✅");
          } catch (error) {
            if (error.name !== "AbortError") {
              alert(`Errore salvataggio: ${error.message}`);
            }
          }
        });

        dom.openFileBtn.addEventListener("click", async () => {
          if (!FileSystem.supported) {
            alert(
              "Il tuo browser non supporta l'apertura diretta. Usa Importa JSON."
            );
            return;
          }
          try {
            const [handle] = await window.showOpenFilePicker({
              types: [
                {
                  description: "JSON",
                  accept: { "application/json": [".json"] },
                },
              ],
            });
            AppState.currentFileHandle = handle;
            const file = await handle.getFile();
            const content = await file.text();
            const parsed = JSON.parse(content);
            if (!validate(parsed)) {
              alert("JSON non valido");
              return;
            }
            AppState.replace(parsed);
            render();
          } catch (error) {
            if (error.name !== "AbortError") {
              alert(`Errore apertura: ${error.message}`);
            }
          }
        });

        dom.clearBtn.addEventListener("click", () => {
          if (!confirmDelete("Sicuro di azzerare tutto?")) return;
          AppState.replace(defaultState());
          render();
        });

        // =============================================================
        // Google Drive integration (opzionale)
        // =============================================================
        const GoogleDrive = {
          CLIENT_ID: localStorage.getItem(STORAGE_KEYS.GD_CLIENT_ID) || "",
          API_KEY: localStorage.getItem(STORAGE_KEYS.GD_API_KEY) || "",
          DISCOVERY_DOCS: GOOGLE_DISCOVERY_DOCS,
          SCOPES: GOOGLE_SCOPE,
          tokenClient: null,
          gapiLoaded: false,
          gisLoaded: false,
          signedIn: false,
          currentFileId: null,
        };

        function updateDriveUI() {
          dom.driveStatus.textContent = GoogleDrive.signedIn
            ? "Drive: connesso"
            : "Drive: offline";
          dom.driveOpenBtn.disabled = !GoogleDrive.signedIn;
          dom.driveSaveBtn.disabled = !GoogleDrive.signedIn;
        }

        function saveDriveCredentials() {
          localStorage.setItem(STORAGE_KEYS.GD_CLIENT_ID, GoogleDrive.CLIENT_ID);
          localStorage.setItem(STORAGE_KEYS.GD_API_KEY, GoogleDrive.API_KEY);
        }

        function askForDriveCredentials() {
          const clientId = prompt(
            "Inserisci il tuo Google OAuth CLIENT_ID (tipo ...apps.googleusercontent.com):",
            GoogleDrive.CLIENT_ID || ""
          );
          if (!clientId) return false;
          const apiKey = prompt(
            "Inserisci la tua Google API KEY:",
            GoogleDrive.API_KEY || ""
          );
          if (!apiKey) return false;
          GoogleDrive.CLIENT_ID = clientId.trim();
          GoogleDrive.API_KEY = apiKey.trim();
          saveDriveCredentials();
          return true;
        }

        function loadGapi() {
          return new Promise((resolve, reject) => {
            if (GoogleDrive.gapiLoaded) {
              resolve();
              return;
            }
            const script = document.createElement("script");
            script.src = "https://apis.google.com/js/api.js";
            script.onload = () => {
              gapi.load("client", async () => {
                try {
                  await gapi.client.init({
                    apiKey: GoogleDrive.API_KEY,
                    discoveryDocs: GoogleDrive.DISCOVERY_DOCS,
                  });
                  GoogleDrive.gapiLoaded = true;
                  resolve();
                } catch (error) {
                  reject(error);
                }
              });
            };
            script.onerror = reject;
            document.head.appendChild(script);
          });
        }

        function loadGoogleIdentityServices() {
          return new Promise((resolve, reject) => {
            if (GoogleDrive.gisLoaded) {
              resolve();
              return;
            }
            const script = document.createElement("script");
            script.src = "https://accounts.google.com/gsi/client";
            script.onload = () => {
              try {
                GoogleDrive.tokenClient = google.accounts.oauth2.initTokenClient({
                  client_id: GoogleDrive.CLIENT_ID,
                  scope: GoogleDrive.SCOPES,
                  callback: (response) => {
                    if (response && response.access_token) {
                      GoogleDrive.signedIn = true;
                      updateDriveUI();
                    }
                  },
                });
                GoogleDrive.gisLoaded = true;
                resolve();
              } catch (error) {
                reject(error);
              }
            };
            script.onerror = reject;
            document.head.appendChild(script);
          });
        }

        async function ensureDriveReady() {
         // if (location.protocol === "file:") {
         //   alert(
         //     "Per usare Google Drive apri la pagina da http://localhost o https://"
         //   );
         //   return false;
         // }
          if (!GoogleDrive.CLIENT_ID || !GoogleDrive.API_KEY) {
            const ok = askForDriveCredentials();
            if (!ok) return false;
          }
          try {
            await loadGoogleIdentityServices();
          } catch (error) {
            alert(`Errore GIS: ${error.message || error}`);
            return false;
          }
          try {
            await loadGapi();
          } catch (error) {
            console.warn("Uso fallback REST (senza discovery):", error);
          }
          return true;
        }

        async function driveFetch(path, params = {}, method = "GET", body = null) {
          const tokenObj = google.accounts.oauth2.getToken?.();
          const token = tokenObj && tokenObj.access_token;
          if (!token) throw new Error('Nessun access token disponibile. Premi "Connetti Google".');
          const url = new URL(`https://www.googleapis.com/drive/v3/${path}`);
          Object.entries(params).forEach(([key, value]) =>
            url.searchParams.set(key, value)
          );
          const response = await fetch(url.toString(), {
            method,
            headers: {
              Authorization: `Bearer ${token}`,
              ...(body ? { "Content-Type": "application/json" } : {}),
            },
            body: body ? JSON.stringify(body) : null,
          });
          if (!response.ok) {
            throw new Error(`Drive REST error ${response.status}: ${await response.text()}`);
          }
          return response.json();
        }

        async function listJsonFilesFallback() {
          const q = "mimeType='application/json' and trashed=false";
          return driveFetch("files", {
            q,
            fields: "files(id,name,modifiedTime)",
            pageSize: "25",
          });
        }

        async function getFileContentFallback(fileId) {
          const tokenObj = google.accounts.oauth2.getToken?.();
          const token = tokenObj && tokenObj.access_token;
          const url = `https://www.googleapis.com/drive/v3/files/${encodeURIComponent(
            fileId
          )}?alt=media`;
          const response = await fetch(url, {
            headers: {
              Authorization: `Bearer ${token}`,
            },
          });
          if (!response.ok) {
            throw new Error(`Download error ${response.status}`);
          }
          return response.text();
        }

        async function uploadOrUpdateJsonFallback(name, content, fileId) {
          const boundary = "-------314159265358979323846";
          const delimiter = `\r\n--${boundary}\r\n`;
          const closeDelimiter = `\r\n--${boundary}--`;
          const metadata = { name, mimeType: "application/json" };
          const multipartBody =
            `${delimiter}Content-Type: application/json; charset=UTF-8\r\n\r\n${JSON.stringify(metadata)}` +
            `${delimiter}Content-Type: application/json\r\n\r\n${content}${closeDelimiter}`;

          const tokenObj = google.accounts.oauth2.getToken?.();
          const token = tokenObj && tokenObj.access_token;
          const method = fileId ? "PATCH" : "POST";
          const path = fileId ? `files/${encodeURIComponent(fileId)}` : "files";
          const response = await fetch(
            `https://www.googleapis.com/upload/drive/v3/${path}?uploadType=multipart`,
            {
              method,
              headers: {
                Authorization: `Bearer ${token}`,
                "Content-Type": `multipart/related; boundary=${boundary}`,
              },
              body: multipartBody,
            }
          );
          if (!response.ok) {
            throw new Error(`Upload error ${response.status}: ${await response.text()}`);
          }
          const json = await response.json();
          return json.id;
        }

        dom.googleBtn.addEventListener("click", async () => {
          if (!(await ensureDriveReady())) return;
          try {
            GoogleDrive.tokenClient.requestAccessToken({ prompt: "consent" });
          } catch (error) {
            alert(`Autorizzazione Google fallita: ${error.message || error}`);
          }
        });

        dom.driveOpenBtn.addEventListener("click", async () => {
          try {
            if (!(await ensureDriveReady())) return;
            let files = [];
            if (GoogleDrive.gapiLoaded && window.gapi?.client?.drive) {
              try {
                const response = await gapi.client.drive.files.list({
                  q: "mimeType='application/json' and trashed=false",
                  pageSize: 25,
                  fields: "files(id,name,modifiedTime)",
                });
                files = response.result.files || [];
              } catch (error) {
                console.warn("gapi list fallita, passo a REST fallback:", error);
              }
            }
            if (!files.length) {
              const response = await listJsonFilesFallback();
              files = response.files || [];
            }
            if (!files.length) {
              alert("Nessun JSON trovato nel tuo Drive.");
              return;
            }
            const nameList = files
              .map(
                (file, index) =>
                  `${index + 1}) ${file.name} — ${new Date(
                    file.modifiedTime
                  ).toLocaleString()}`
              )
              .join("\n");
            const idx = prompt(`Scegli file da aprire (numero):\n${nameList}`);
            const selectedIndex = Number(idx) - 1;
            if (!(selectedIndex >= 0 && selectedIndex < files.length)) return;
            const file = files[selectedIndex];
            let text;
            if (GoogleDrive.gapiLoaded && window.gapi?.client?.drive) {
              try {
                const download = await gapi.client.drive.files.get({
                  fileId: file.id,
                  alt: "media",
                });
                text = download.body;
              } catch (error) {
                console.warn("gapi download fallito, uso REST:", error);
                text = await getFileContentFallback(file.id);
              }
            } else {
              text = await getFileContentFallback(file.id);
            }
            const data = JSON.parse(text);
            if (!validate(data)) {
              alert("JSON non valido");
              return;
            }
            AppState.replace(data);
            GoogleDrive.currentFileId = file.id;
            alert(`Aperto da Drive: ${file.name}`);
            render();
          } catch (error) {
            alert(`Errore apertura Drive: ${error.message || error}`);
          }
        });

        dom.driveSaveBtn.addEventListener("click", async () => {
          try {
            if (!(await ensureDriveReady())) return;
            const fileName = DEFAULT_FILE_NAME;
            const content = JSON.stringify(AppState.data, null, 2);
            if (GoogleDrive.gapiLoaded && window.gapi?.client?.drive) {
              try {
                const boundary = "-------314159265358979323846";
                const delimiter = `\r\n--${boundary}\r\n`;
                const closeDelimiter = `\r\n--${boundary}--`;
                const metadata = { name: fileName, mimeType: "application/json" };
                const multipartBody =
                  `${delimiter}Content-Type: application/json; charset=UTF-8\r\n\r\n${JSON.stringify(metadata)}` +
                  `${delimiter}Content-Type: application/json\r\n\r\n${content}${closeDelimiter}`;

                if (GoogleDrive.currentFileId) {
                  await gapi.client.request({
                    path: `/upload/drive/v3/files/${encodeURIComponent(
                      GoogleDrive.currentFileId
                    )}`,
                    method: "PATCH",
                    params: { uploadType: "multipart" },
                    headers: {
                      "Content-Type": `multipart/related; boundary=${boundary}`,
                    },
                    body: multipartBody,
                  });
                  alert("Aggiornato su Drive ✅");
                } else {
                  const response = await gapi.client.request({
                    path: "/upload/drive/v3/files",
                    method: "POST",
                    params: { uploadType: "multipart" },
                    headers: {
                      "Content-Type": `multipart/related; boundary=${boundary}`,
                    },
                    body: multipartBody,
                  });
                  GoogleDrive.currentFileId = response.result?.id || null;
                  alert("Salvato su Drive ✅");
                }
                return;
              } catch (error) {
                console.warn("gapi upload fallito, uso REST:", error);
              }
            }
            GoogleDrive.currentFileId = await uploadOrUpdateJsonFallback(
              fileName,
              content,
              GoogleDrive.currentFileId
            );
            alert("Salvato su Drive (REST) ✅");
          } catch (error) {
            alert(`Errore salvataggio Drive: ${error.message || error}`);
          }
        });

        updateDriveUI();
        render();
      })();
    </script>
  </body>
</html>
